!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!Copyright 2007.  Los Alamos National Security, LLC. This material was
!produced under U.S. Government contract DE-AC52-06NA25396 for Los
!Alamos National Laboratory (LANL), which is operated by Los Alamos
!National Security, LLC for the U.S. Department of Energy. The
!U.S. Government has rights to use, reproduce, and distribute this
!software.  NEITHER THE GOVERNMENT NOR LOS ALAMOS NATIONAL SECURITY,
!LLC MAKES ANY WARRANTY, EXPRESS OR IMPLIED, OR ASSUMES ANY LIABILITY
!FOR THE USE OF THIS SOFTWARE.  If software is modified to produce
!derivative works, such modified software should be clearly marked, so
!as not to confuse it with the version available from LANL.
!
!Additionally, this program is free software; you can redistribute it
!and/or modify it under the terms of the GNU General Public License as
!published by the Free Software Foundation; either version 2 of the
!License, or (at your option) any later version. Accordingly, this
!program is distributed in the hope that it will be useful, but WITHOUT
!ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
!FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
!for more details.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#include "macros.h"

module sforcing
implicit none

type wnforcing_d
   integer :: n
   ! note: SGI f90 does not allow allocatable arrays in a struct
   integer, pointer :: index(:,:)
end type

integer           :: numb1,numb
integer,parameter :: numb_max=512
integer,parameter :: numbs=3         ! max stochastic forcing bands
real*8            :: FM(numbs)       ! stochastic forcing normalization
type(wnforcing_d),allocatable :: wnforcing(:)

integer,private :: ntot=0
integer :: init_sforcing=0
integer :: comm_sforcing  ! MPI communicator for all pe's involved in forcing

real*8 :: ener_target(numb_max)

contains




subroutine sforce(rhs,Qhat,f_diss,fxx_diss)
!
! Add a forcing term to rhs, in spectral space.
!
use params
implicit none
real*8 :: Qhat(*)
real*8 :: rhs(*)
real*8 :: f_diss,param,fxx_diss

! determinisitic with E1=E2=.5
if (forcing_type==1) call sforcing12(rhs,Qhat,f_diss,fxx_diss,0)

! stochastic, wave numbers 1,2   input file name: 'iso12w'
if (forcing_type==2) call sforcing_random12(rhs,Qhat,f_diss,fxx_diss,0)

! determinisitic with Overholt and Pope spectrum   input file name: 'iso'
if (forcing_type==3) call sforcing12(rhs,Qhat,f_diss,fxx_diss,1)

! stochastic, wave numbers 2,3
if (forcing_type==4) call sforcing_random12(rhs,Qhat,f_diss,fxx_diss,0)

! determinisitic - Balu: single high wave number 
! This forcing is handled in ns.F90    input file name: 'balu'
if (forcing_type==5) call sforcing12(rhs,Qhat,f_diss,fxx_diss,2)

! determinisitic with E1=E2=.5, also impose helicity   input file name: 'iso12_hel'
if (forcing_type==6) call sforcing12_helicity(rhs,Qhat,f_diss,fxx_diss,0)

! determinisitic - high wavenumber   input file name: 'iso_high_24', 'iso_high_16'
if (forcing_type==7) call sforcing12(rhs,Qhat,f_diss,fxx_diss,3)

! stochastic high wavenumber forcing
if (forcing_type==8) call stochastic_highwaveno(rhs,Qhat,f_diss,fxx_diss,0)

! determinisitic with E1=1.0   input file name: 'iso1'
if (forcing_type==9) call sforcing12(rhs,Qhat,f_diss,fxx_diss,4)

! determinisitic E(1) only, with fixed epsilon, also impose helicity   
! input file name: 'iso1_hel'
if (forcing_type==10) call sforcing12_helicity_fixepsilon(rhs,Qhat,f_diss,fxx_diss,1)


if (Lz/=1 .and. forcing_type/=8) then
   call abortdns("Error: only forcing_type==8 has been coded for Lz<>1")
endif


end subroutine




subroutine gforce(Q,rhs,rhsz,q4,q4z,work,f_diss,fxx_diss)
!
! store forcing term to rhs, in gird space
!
use params
use fft_interface
implicit none
real*8 :: work(nx,ny,nz)
real*8 :: Q(nx,ny,nz,3)
real*8 :: q4(nx,ny,nz,3)
real*8 :: rhs(nx,ny,nz,3)
real*8 :: q4z(g_nz2,nx_2dz,ny_2dz,3) 
real*8 :: rhsz(g_nz2,nx_2dz,ny_2dz,3) 
real*8 :: f_diss,fxx_diss

! local
integer :: n
real*8 :: fdiss,fxxdiss,xfac,xw
integer im,jm,km,i,j,k


q4=Q
do n=1,3
   call z_fft3d_trashinput(q4(1,1,1,n),rhsz(1,1,1,n),work)
enddo
q4z=0

call sforce(q4z,rhsz,fdiss,fxxdiss)
do n=1,3
   call z_ifft3d(q4z(1,1,1,n),rhs(1,1,1,n),work)
enddo
f_diss=fdiss  ! strange bug on SGI, dnsghost, f_diss is non zero here, but
              ! return value in ns_ghost.F90 is 0.  if we introduce 'fdiss',
              ! everthing is ok
fxx_diss=fxxdiss
return
end subroutine






subroutine sforcing12(rhs,Qhat,f_diss,fxx_diss,model_spec)
!
! Add a forcing term to rhs.
! Force 3D wave numbers 1 back to the sphere E=1**(-5/3)
! Force 3D wave numbers 2 back to the sphere E=2**(-5/3)
!
! model_spec==0    E(1)=E(2)=.5            'iso12' option
! model_spec==1    Overholt & Pope
! model_spec==2    Balu
! model_spec==3    high wave number for rotation case
! model_spec==4    E(1) = 1.0              'iso1' option
!
use params
use mpi
implicit none
real*8 :: Qhat(g_nz2,nx_2dz,ny_2dz,3) 
real*8 :: rhs(g_nz2,nx_2dz,ny_2dz,3) 
integer :: model_spec
integer km,jm,im,i,j,k,n,wn,ierr,kfmax
real*8 xw,xfac,f_diss,tauf,tau_inv,fxx_diss
real*8 ener(numb_max),temp(numb_max)
character(len=80) :: message


if (0==init_sforcing) then
   numb1=1
   if (model_spec==0) then                        ! 'iso12' option
      numb=2   ! apply forcing in bands 1,2
      call sforcing_init()
      do wn=numb1,numb
         ener_target(wn)=.5
      enddo
   endif
   if (model_spec==1) then                         ! 'iso' option   Overhold&Pope
      numb=8
      call sforcing_init()
      do wn=numb1,numb
         ener_target(wn)=(real(wn)/numb)**4
      enddo
   endif
   if (model_spec==2) then     ! balu forcing      ' bal  
      numb1=dealias_23_kmax-1
      numb=dealias_23_kmax
      call sforcing_init()
      do wn=numb1,numb
         ener_target(wn)=wn**(-5./3.)
      enddo
   endif
   if (model_spec==3) then     ! For the rotation case  
      numb1=max(forcing_peak_waveno-8,1)
      numb=forcing_peak_waveno+8
      call sforcing_init()
      do wn=numb1,numb
         ener_target(wn)=exp(-.5*(wn-forcing_peak_waveno)**2)/sqrt(2*pi)
      enddo
   endif
   if (model_spec==4) then                        ! 'iso1' option
      numb=1   ! apply forcing in bands 1 only
      call sforcing_init()
      do wn=numb1,numb
         ener_target(wn)=1.0
      enddo
   endif
   if (numb>numb_max) call abortdns("sforcing12: numb_max too small")
   if (io_pe==my_pe) then
      print *,'Using Deterministic Low Wave Number Forcing. Target spectrum:'
      do wn=numb1,numb
         print *,'shell k=',wn,'  energy=',ener_target(wn)
      enddo
   endif
endif


if (g_u2xave==0) then
   ! on first call, this will not have been computed, so lets
   ! compute it here:  ints(2)
   g_u2xave=0
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)
            
            xw=(im*im + jm*jm + km*km)*pi2_squared
            
            xfac = 2*2*2
            if (km==0) xfac=xfac/2
            if (jm==0) xfac=xfac/2
            if (im==0) xfac=xfac/2
            
            
            g_u2xave = g_u2xave + xfac*xw*(Qhat(k,i,j,1)**2 + &
                 Qhat(k,i,j,2)**2 + &
                 Qhat(k,i,j,3)**2) 
            
         enddo
      enddo
   enddo
#ifdef USE_MPI
   xw=g_u2xave
   call mpi_allreduce(xw,g_u2xave,1,MPI_REAL8,MPI_SUM,comm_3d,ierr)
#endif

endif


if (ntot==0) return
! only CPUS which belong to "comm_sforcing" beyond this point!


! relaxation coefficient (below) and kfmax (above) 
! comes from Overhold and Pope 1998.    .5 = tau/tau_kolmogorov
! tau = .5 tau_kolmogorov = .5 eta^2 / mu = .5 sqrt(mu/epsilon) = 
!                                           .5/sqrt( <ux,ux> ) 
!  
tau_inv=sqrt(g_u2xave)/.5



f_diss=0
fxx_diss=0
ener=0
do wn=numb1,numb

   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)
      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2
      ener(wn)=ener(wn)+.5*xfac*(Qhat(k,i,j,1)**2+Qhat(k,i,j,2)**2+Qhat(k,i,j,3)**2)
   enddo
enddo
#ifdef USE_MPI
   temp=ener
   call mpi_allreduce(temp,ener,numb,MPI_REAL8,MPI_SUM,comm_sforcing,ierr)
#endif


do wn=numb1,numb
   ! Qf = Q*sqrt(ener_target/ener)
   ! forcing = 1/tau (Qf-Q) = 1/tau * (sqrt(ener_target/ener)-1) Q
   tauf=tau_inv*(sqrt(ener_target(wn)/ener(wn))-1)

   ! make sure relaxation is stable:
   if (delt*tauf>.5) tauf=.5/delt

!   if (io_pe==my_pe) &
!   write(*,'(a,3i4,2f17.10,e17.10)') 'FORCING:',my_pe,wn,wnforcing(wn)%n,ener(wn),ener_target(wn),tauf

   if (tauf>0) then ! only apply forcing if net input is positive
   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)
      rhs(k,i,j,1) = rhs(k,i,j,1) + tauf*Qhat(k,i,j,1)
      rhs(k,i,j,2) = rhs(k,i,j,2) + tauf*Qhat(k,i,j,2)
      rhs(k,i,j,3) = rhs(k,i,j,3) + tauf*Qhat(k,i,j,3)

      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2
      f_diss = f_diss + xfac*tauf*(Qhat(k,i,j,1)**2 + &
           Qhat(k,i,j,2)**2 + &
           Qhat(k,i,j,3)**2) 

      xw=-(z_imcord(i)**2 + z_jmcord(j)**2 + z_kmcord(k)**2)*pi2_squared
      fxx_diss = fxx_diss + xfac*tauf*xw*(Qhat(k,i,j,1)**2 + &
                                Qhat(k,i,j,2)**2 + &
                                Qhat(k,i,j,3)**2) 



   enddo
   endif

enddo
end subroutine 
   
   








subroutine sforcing12_helicity(rhs,Qhat,f_diss,fxx_diss,model_spec)
!
! Add a forcing term to rhs.
! Force 3D wave numbers 1 back to the sphere E=1**(-5/3)
! Force 3D wave numbers 2 back to the sphere E=2**(-5/3)
!
! and in addition, force to a prescribed angle to impose some helicity
!
! model_spec==0    E(1)=E(2)=.5
! model_spec==1    Overholt & Pope
! model_spec==2    forcing in E(1)
!
use params
use mpi
implicit none
real*8 :: Qhat(g_nz2,nx_2dz,ny_2dz,3) 
real*8 :: rhs(g_nz2,nx_2dz,ny_2dz,3) 
integer :: model_spec
integer km,jm,im,i,j,k,k2,n,wn,ierr,kfmax,fix
real*8 xw,xfac,f_diss,tauf,tau_inv,fxx_diss
real*8 ener(numb_max),temp(numb_max),Qdel(3)
real*8,allocatable,save :: rmodes(:,:,:,:)
real*8,allocatable,save :: rmodes2(:,:,:,:)
real*8,allocatable,save :: cmodes(:,:,:,:,:)
real*8 RR(3),II(3), IIp(3), RRhat(3), khat(3), yhat(3),RRxk_hat(3), IIxk_hat(3),RRxIIp(3)
real*8 mod_ii, mod_rr, mod_IIp, mod_RRxk, RRdotk, IIdotk, RRdotII, RRdotIIp, mod_IIxk
real*8 costta, tta, tta_sgn, theta,  phi 
real*8,save :: h_angle,cos_h_angle,sin_h_angle
character(len=80) :: message



if (0==init_sforcing) then
   !should have h_angle inputted by user eventually
   h_angle = 0.0d0
!   h_angle = pi/2
   cos_h_angle=cos(h_angle)
   sin_h_angle=sin(h_angle)

   numb1=1
   if (model_spec==0) then
      numb=2   ! apply forcing in bands 1,2
      do wn=numb1,numb
         ener_target(wn)=.5
      enddo
   endif
   if (model_spec==1) then
      numb=8
      do wn=numb1,numb
         ener_target(wn)=(real(wn)/numb)**4
      enddo
   endif
   if (model_spec==2) then
      numb=1
      do wn=numb1,numb
         ener_target(wn)=0   ! ener_target is not used
      enddo
   endif
   if (numb>numb_max) call abortdns("sforcing12_helicity: numb_max too small")
   call sforcing_init()
endif

!
!  compute grad(u)^2, used for O&P type relaxation coeffient
!  (not needed for prescribed epsilon forcing)
!
if (g_u2xave==0) then
   ! on first call, this will not have been computed, so lets
   ! compute it here:  ints(2)
   g_u2xave=0
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)
            
            xw=(im*im + jm*jm + km*km)*pi2_squared
            
            xfac = 2*2*2
            if (km==0) xfac=xfac/2
            if (jm==0) xfac=xfac/2
            if (im==0) xfac=xfac/2
            
            
            g_u2xave = g_u2xave + xfac*xw*(Qhat(k,i,j,1)**2 + &
                 Qhat(k,i,j,2)**2 + &
                 Qhat(k,i,j,3)**2) 
            
         enddo
      enddo
   enddo
#ifdef USE_MPI
   xw=g_u2xave
   call mpi_allreduce(xw,g_u2xave,1,MPI_REAL8,MPI_SUM,comm_3d,ierr)
#endif

endif


if (ntot==0) return
! only CPUS which belong to "comm_sforcing" beyond this point!


! relaxation coefficient (below) and kfmax (above) 
! comes from Overhold and Pope 1998.    .5 = tau/tau_kolmogorov
! tau = .5 tau_kolmogorov = .5 eta^2 / mu = .5 sqrt(mu/epsilon) = 
!                                           .5/sqrt( <ux,ux> ) 
!  
tau_inv=sqrt(g_u2xave)/.5

if (.not. allocated(rmodes)) then
   allocate(rmodes(-numb:numb,-numb:numb,-numb:numb,3))
   allocate(rmodes2(-numb:numb,-numb:numb,-numb:numb,3))
   allocate(cmodes(2,-numb:numb,-numb:numb,-numb:numb,3))
endif


!
! compute E(k), and convert from sin/cos to complex mode representation
!
f_diss=0
fxx_diss=0
ener=0
rmodes=0
do wn=numb1,numb

   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)
      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2
      ener(wn)=ener(wn)+.5*xfac*(Qhat(k,i,j,1)**2+Qhat(k,i,j,2)**2+Qhat(k,i,j,3)**2)

      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1)=Qhat(k,i,j,1)
      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2)=Qhat(k,i,j,2)
      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3)=Qhat(k,i,j,3)
   enddo
enddo
#ifdef USE_MPI
   temp=ener
   call mpi_allreduce(temp,ener,numb,MPI_REAL8,MPI_SUM,comm_sforcing,ierr)
   rmodes2=rmodes
   i=2*numb+1
   i=3*i*i*i
   call mpi_allreduce(rmodes2,rmodes,i,MPI_REAL8,MPI_SUM,comm_sforcing,ierr)
#endif


! Qf = Q*sqrt(ener_target/ener)
do wn=numb1,numb
   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)
      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),:)= &
         sqrt(ener_target(wn)/ener(wn))*&
         rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),:)
   enddo
enddo

do n=1,3
   ! note: using rmodes(:,:,:,n) fails under ifc/linux.  why?
   call sincos_to_complex(rmodes(-numb,-numb,-numb,n),&
      cmodes(1,-numb,-numb,-numb,n),numb)
enddo

      
!     apply helicity fix:
do i=-numb,numb
do j=-numb,numb
do k=-numb,numb
   k2=i**2 + j**2 + k**2
   if (k2>0 .and. k2 < (.5+numb)**2 ) then
      RR = cmodes(1,i,j,k,:)
      II = cmodes(2,i,j,k,:)
      mod_rr = sqrt(RR(1)*RR(1) + RR(2)*RR(2) + RR(3)*RR(3))
      mod_ii = sqrt(II(1)*II(1) + II(2)*II(2) + II(3)*II(3))

      fix = 1
      if (mod_rr == 0 .or. mod_ii ==0 .or. k2 == 0) then
         fix = 0
      endif
      
!     do the transformation if fix = 1
      if (fix == 1) then         

         RRhat = RR/mod_rr
         khat(1) = i/sqrt(k2*1.0d0)
         khat(2) = j/sqrt(k2*1.0d0)
         khat(3) = k/sqrt(k2*1.0d0)
         
!        yhat = khat X RRhat (coordinate system with zhat=khat and xhat = RRhat
         yhat(1) = khat(2)*RRhat(3) - khat(3)*RRhat(2)
         yhat(2) = - (khat(1)*RRhat(3) - khat(3)*RRhat(1))
         yhat(3) = khat(1)*RRhat(2) - khat(2)*RRhat(1)
         
         IIp = II	

!        write II in terms of new coordinate system (z=khat,x=RRhat,y=yhat)
         
         II(1) = IIp(1)*RRhat(1) + IIp(2)*RRhat(2) + IIp(3)*RRhat(3)
         II(2) = IIp(1)*yhat(1) + IIp(2)*yhat(2) + IIp(3)*yhat(3)
         II(3) = IIp(1)*khat(1) + IIp(2)*khat(2) + IIp(3)*khat(3) !should be zero
                  
!        set II to have angle h_angle wrt RR
         IIp(1) = cos_h_angle*mod_ii
         IIp(2) = sin_h_angle*mod_ii
         IIp(3) = II(3)
         
         
         ! now write II in old (i,j,k) coordinate system
         II(1) = IIp(1)*RRhat(1) + IIp(2)*yhat(1) + IIp(3)*khat(1)
         II(2) = IIp(1)*RRhat(2) + IIp(2)*yhat(2) + IIp(3)*khat(2)
         II(3) = IIp(1)*RRhat(3) + IIp(2)*yhat(3) + IIp(3)*khat(3)
         
      
         cmodes(1,i,j,k,:) = RR	
         cmodes(2,i,j,k,:) = II	
      endif
   endif
enddo
enddo
enddo
      
!
!  The helicity adjustment above did not preserve the fact that
!  mode (l,m,n) needs to be the complex conjugate of mode (-l,-m,-n)
!  Reimpose this constraint:
!
do n=1,3
do i=0,numb
do j=-numb,numb
do k=-numb,numb
   !cmodes(1,i,j,k,n) =  cmodes(1,-i,-j,-k,n)
   cmodes(2,i,j,k,n) = -cmodes(2,-i,-j,-k,n)
   !write(*,'(3i3,4f12.8)') i,j,k,cmodes(2,i,j,k,n),cmodes(2,-i,-j,-k,n),&
   !        cmodes(2,i,j,k,n)+cmodes(2,-i,-j,-k,n)
enddo
enddo
enddo
enddo


!     convert back:
do n=1,3
      call complex_to_sincos(rmodes(-numb,-numb,-numb,n),&
      cmodes(1,-numb,-numb,-numb,n),numb)
enddo


do wn=numb1,numb
   ! original, without helicity changes:
   !    Qf = Q*sqrt(ener_target/ener)
   !    forcing = 1/tau (Qf-Q) = 1/tau * (sqrt(ener_target/ener)-1) Q
   ! but now we've changed the phase of Qf, and thus we keep the form:
   !    forcing = 1/tau ( Qf - Q )

   tauf=tau_inv
   ! make sure tauf is not too large that forcing is unstable:
   if (delt*tau_inv*(sqrt(ener_target(wn)/ener(wn))-1) > .5) then
         tauf = .5/(delt*(sqrt(ener_target(wn)/ener(wn))-1))
   endif


   if (ener(wn)<ener_target(wn)) then ! only apply forcing if net input is positive
   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)

      Qdel(1)=tauf*(rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1)-Qhat(k,i,j,1))
      Qdel(2)=tauf*(rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2)-Qhat(k,i,j,2))
      Qdel(3)=tauf*(rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3)-Qhat(k,i,j,3))


      rhs(k,i,j,1) = rhs(k,i,j,1) + Qdel(1)
      rhs(k,i,j,2) = rhs(k,i,j,2) + Qdel(2)
      rhs(k,i,j,3) = rhs(k,i,j,3) + Qdel(3)

      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2
      f_diss = f_diss + xfac*(Qdel(1)*Qhat(k,i,j,1) +&
                              Qdel(2)*Qhat(k,i,j,2) + &
                              Qdel(3)*Qhat(k,i,j,3) ) 

      xw=-(z_imcord(i)**2 + z_jmcord(j)**2 + z_kmcord(k)**2)*pi2_squared
      fxx_diss = fxx_diss + xfac*xw*(Qdel(1)**2 + Qdel(2)**2 + Qdel(3)**2) 

   enddo
   endif

enddo
end subroutine 
   




subroutine sforcing12_helicity_fixepsilon(rhs,Qhat,f_diss,fxx_diss,numb_in)
!
! Add a forcing term to rhs.
! Force 3D wave numbers 1 back to the sphere E=1**(-5/3)
! Force 3D wave numbers 2 back to the sphere E=2**(-5/3)
!
! and in addition, force to a prescribed angle to impose some helicity
!
! forcing appied in bands k=numb1,numb
!
use params
use mpi
implicit none
real*8 :: Qhat(g_nz2,nx_2dz,ny_2dz,3) 
real*8 :: rhs(g_nz2,nx_2dz,ny_2dz,3) 
integer :: numb_in

integer km,jm,im,i,j,k,k2,n,wn,ierr,kfmax,fix
real*8 xw,xfac,f_diss,tau1,tau2,fxx_diss,e1,e2
real*8 QdotQf(numb_max),QdotQ(numb_max),temp(numb_max),RdotR(numb_max),Qdel(3)
real*8,allocatable,save :: rmodes(:,:,:,:)
real*8,allocatable,save :: rmodes2(:,:,:,:)
real*8,allocatable,save :: cmodes(:,:,:,:,:)
real*8 RR(3),II(3), IIp(3), RRhat(3), khat(3), yhat(3),RRxk_hat(3), IIxk_hat(3),RRxIIp(3)
real*8 mod_ii, mod_rr, mod_IIp, mod_RRxk, RRdotk, IIdotk, RRdotII, RRdotIIp, mod_IIxk
real*8 costta, tta, tta_sgn, theta,  phi 
real*8,save :: h_angle,cos_h_angle,sin_h_angle
character(len=80) :: message

integer, save :: tau_output_count=0

numb1=1
numb = numb_in
if (0==init_sforcing) then
   h_angle = fparam1*pi/180 ! from input file
   cos_h_angle=cos(h_angle)
   sin_h_angle=sin(h_angle)

   if (numb>numb_max) call abortdns("sforcing12_helicity: numb_max too small")
   call sforcing_init()
endif


if (ntot==0) return
! only CPUS which belong to "comm_sforcing" beyond this point!


if (.not. allocated(rmodes)) then
   allocate(rmodes(-numb:numb,-numb:numb,-numb:numb,3))
   allocate(rmodes2(-numb:numb,-numb:numb,-numb:numb,3))
   allocate(cmodes(2,-numb:numb,-numb:numb,-numb:numb,3))
endif
!
! compute E(k), and convert from sin/cos to complex mode representation
!
QdotQ=0
rmodes=0
do wn=numb1,numb

   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)
      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2
      QdotQ(wn)=QdotQ(wn)+xfac*(Qhat(k,i,j,1)**2+Qhat(k,i,j,2)**2+Qhat(k,i,j,3)**2)

      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1)=Qhat(k,i,j,1)
      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2)=Qhat(k,i,j,2)
      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3)=Qhat(k,i,j,3)
   enddo
enddo
#ifdef USE_MPI
   temp=QdotQ
   call mpi_allreduce(temp,QdotQ,numb,MPI_REAL8,MPI_SUM,comm_sforcing,ierr)
   rmodes2=rmodes
   i=2*numb+1
   i=3*i*i*i
   call mpi_allreduce(rmodes2,rmodes,i,MPI_REAL8,MPI_SUM,comm_sforcing,ierr)
#endif


do n=1,3
   ! note: using rmodes(:,:,:,n) fails under ifc/linux.  why?
   call sincos_to_complex(rmodes(-numb,-numb,-numb,n),&
      cmodes(1,-numb,-numb,-numb,n),numb)
enddo

      
!     apply helicity fix:
do i=-numb,numb
do j=-numb,numb
do k=-numb,numb
   k2=i**2 + j**2 + k**2
   if (k2>0 .and. k2 < (.5+numb)**2 ) then
      RR = cmodes(1,i,j,k,:)
      II = cmodes(2,i,j,k,:)
      mod_rr = sqrt(RR(1)*RR(1) + RR(2)*RR(2) + RR(3)*RR(3))
      mod_ii = sqrt(II(1)*II(1) + II(2)*II(2) + II(3)*II(3))

      fix = 1
      if (mod_rr == 0 .or. mod_ii ==0 .or. k2 == 0) then
         fix = 0
      endif
      
!     do the transformation if fix = 1
      if (fix == 1) then         

         RRhat = RR/mod_rr
         khat(1) = i/sqrt(k2*1.0d0)
         khat(2) = j/sqrt(k2*1.0d0)
         khat(3) = k/sqrt(k2*1.0d0)
         
!        yhat = khat X RRhat (coordinate system with zhat=khat and xhat = RRhat
         yhat(1) = khat(2)*RRhat(3) - khat(3)*RRhat(2)
         yhat(2) = - (khat(1)*RRhat(3) - khat(3)*RRhat(1))
         yhat(3) = khat(1)*RRhat(2) - khat(2)*RRhat(1)
         
         IIp = II	

!        write II in terms of new coordinate system (z=khat,x=RRhat,y=yhat)
         
         II(1) = IIp(1)*RRhat(1) + IIp(2)*RRhat(2) + IIp(3)*RRhat(3)
         II(2) = IIp(1)*yhat(1) + IIp(2)*yhat(2) + IIp(3)*yhat(3)
         II(3) = IIp(1)*khat(1) + IIp(2)*khat(2) + IIp(3)*khat(3) !should be zero
                  
!        set II to have angle h_angle wrt RR
         IIp(1) = cos_h_angle*mod_ii
         IIp(2) = sin_h_angle*mod_ii
         IIp(3) = II(3)
         
         
         ! now write II in old (i,j,k) coordinate system
         II(1) = IIp(1)*RRhat(1) + IIp(2)*yhat(1) + IIp(3)*khat(1)
         II(2) = IIp(1)*RRhat(2) + IIp(2)*yhat(2) + IIp(3)*khat(2)
         II(3) = IIp(1)*RRhat(3) + IIp(2)*yhat(3) + IIp(3)*khat(3)
         
      
         cmodes(1,i,j,k,:) = RR	
         cmodes(2,i,j,k,:) = II	
      endif
   endif
enddo
enddo
enddo

!
!  The helicity adjustment above did not preserve the fact that
!  mode (l,m,n) needs to be the complex conjugate of mode (-l,-m,-n)
!  Reimpose this constraint:
!
do n=1,3
do i=0,numb
do j=-numb,numb
do k=-numb,numb
   !cmodes(1,i,j,k,n) =  cmodes(1,-i,-j,-k,n)
   cmodes(2,i,j,k,n) = -cmodes(2,-i,-j,-k,n)
   !write(*,'(3i3,4f12.8)') i,j,k,cmodes(2,i,j,k,n),cmodes(2,-i,-j,-k,n),&
   !        cmodes(2,i,j,k,n)+cmodes(2,-i,-j,-k,n)
enddo
enddo
enddo
enddo


      
!     convert back:
do n=1,3
      call complex_to_sincos(rmodes(-numb,-numb,-numb,n),&
      cmodes(1,-numb,-numb,-numb,n),numb)
enddo


!
! now compute energy dissipation rate from Q dot rmodes:
!
QdotQf=0
RdotR = 0
do wn=numb1,numb

   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)
      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2

      QdotQf(wn)=QdotQf(wn) + xfac*( &
           rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1)*Qhat(k,i,j,1) + &
           rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2)*Qhat(k,i,j,2) + &
           rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3)*Qhat(k,i,j,3) )

      RdotR(wn)=RdotR(wn) + xfac*( &
           rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1)**2 + &
           rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2)**2 + &
           rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3)**2 )

   enddo
enddo
#ifdef USE_MPI
   temp=QdotQf
   call mpi_allreduce(temp,QdotQf,numb,MPI_REAL8,MPI_SUM,comm_sforcing,ierr)
   temp=RdotR
   call mpi_allreduce(temp,RdotR,numb,MPI_REAL8,MPI_SUM,comm_sforcing,ierr)
#endif


! Forcing function:
!    Q = (u,v,w) state vector in shells for which forcing is applied
!    Qf = adjusted Q to maximimize helizity
! Forcing relaxes Q back to QF.  But we also add a tau2 term to inject
! energy even when Q already has maximum helicity: 
!    forcing = tau1 ( Qf - Q )   + tau2 Q  = tau1 Qf + (tau2-tau1) Q
!
!    QdotQ(k)    =  integral of Q^2 in shell k  = 2 E(k)
!    RdotR(k)    =  integral of Qf^2 in shell k = 2 E(k)
!
!    QdotQf(k)  =  integral of <Q,Qf> in shell k
!
!   <Q,Qf>  <=  ||Q|| ||Qf|| = Q^2
!    e1 = sum_k QdotQf(k) - QdotQ(k)  <= 0
!    e2 = sum_k QdotQ(k)
!
!  For a fixed energy dissipation rate, we pick tau1 and tau2 so that:
!
!  epsilon = tau1 e1 + tau2 e2       
!
!  JHU wants to take tau1 = 1/delt and then determine e2 to get the desired 
!  epsilon.  
!  
!  MT does not like making tau1 depend on delt, since that
!  means the forcing term no longer has a PDE representation.  Since 
!  delt is adjusted
!  based on how often diagnostics are computed, so now the solution will
!  depend on the diagnostics setting output.
!  
e1=0
e2=0
do wn=numb1,numb
   ! check that helicity fix did not change energy:
   if ( abs(QdotQ(wn) -  RdotR(wn) ) > (1e-30 + 1e-6*QdotQ(wn)) ) then
       write(*,'(a,i3,3e15.8)') 'WARNING: Helicity Fix has changed energy: Q^2, QF^2  ',&
       wn,QdotQ(wn),RdotR(wn)
   endif
   e1=e1 + QdotQf(wn)-QdotQ(wn)
   e2=e2 + QdotQ(wn)
enddo

if (delt>0) then
   tau1 = 1/delt
   tau2 = (ffval - tau1*e1) / e2
   if (tau2>tau1) tau2=tau1      ! for stability
else
   tau1 = 0
   tau2 = 0
endif

if (tau_output_count<1000) then
if (io_pe.eq.my_pe) then
   tau_output_count=tau_output_count+1
   write(*,'(a,2e15.6)') 'tau1,tau2',tau1,tau2
endif
endif


f_diss=0
fxx_diss=0
do wn=numb1,numb
   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)

      Qdel(1)=tau1*rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1) + ( tau2-tau1)*Qhat(k,i,j,1)
      Qdel(2)=tau1*rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2) + ( tau2-tau1)*Qhat(k,i,j,2)
      Qdel(3)=tau1*rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3) + ( tau2-tau1)*Qhat(k,i,j,3)


      rhs(k,i,j,1) = rhs(k,i,j,1) + Qdel(1)
      rhs(k,i,j,2) = rhs(k,i,j,2) + Qdel(2)
      rhs(k,i,j,3) = rhs(k,i,j,3) + Qdel(3)

      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2
      f_diss = f_diss + xfac*(Qdel(1)*Qhat(k,i,j,1) +&
                              Qdel(2)*Qhat(k,i,j,2) + &
                              Qdel(3)*Qhat(k,i,j,3) ) 

      xw=-(z_imcord(i)**2 + z_jmcord(j)**2 + z_kmcord(k)**2)*pi2_squared
      fxx_diss = fxx_diss + xfac*xw*(Qdel(1)**2 + Qdel(2)**2 + Qdel(3)**2) 

   enddo
enddo


end subroutine 
   






   
subroutine sforcing_init
!
! build data structure of modes with wave number 0<k<2.5
!
use params
use mpi
implicit none
real*8 :: xw
integer km,jm,im,i,j,k,n,wn,ierr
integer :: color,key
character(len=80) :: message

init_sforcing=1
allocate(wnforcing(numb1:numb))


   do n=numb1,numb
      wnforcing(n)%n=0
   enddo
   
   ! count the number of wavenumbers in each band on this CPU.  
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)

            xw=sqrt(real(km**2+jm**2+im**2))
            do n=numb1,numb
               if (xw>=n-.5 .and. xw<n+.5) then
                  wnforcing(n)%n=wnforcing(n)%n+1
               endif
            enddo

         enddo
      enddo
   enddo
   
   ! allocate storage
   do n=numb1,numb
      i=wnforcing(n)%n
      if (i>0) allocate(wnforcing(n)%index(i,3))
      wnforcing(n)%n=0  ! reset counter to use again below
   enddo
   
   ! store all the indexes
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)

            xw=sqrt(real(km**2+jm**2+im**2))
            do n=numb1,numb
            if (xw>=n-.5 .and. xw<n+.5) then
               wnforcing(n)%n=wnforcing(n)%n+1
               wnforcing(n)%index(wnforcing(n)%n,1)=i
               wnforcing(n)%index(wnforcing(n)%n,2)=j
               wnforcing(n)%index(wnforcing(n)%n,3)=k
            endif
            enddo

         enddo
      enddo
   enddo



ntot=0
do wn=numb1,numb
   ntot=ntot+wnforcing(wn)%n
enddo

color = 0
if (ntot>0) color=1
key=0

! everyone with ntot>0 joins a new group, comm_sforcing
#ifdef USE_MPI
call mpi_comm_split(comm_3d,color,key,comm_sforcing,ierr);
if (ntot==0) call mpi_comm_free(comm_sforcing,ierr)
#endif



end subroutine








subroutine sforcing_random12(rhs,Qhat,f_diss,fxx_diss,new_f)
!
! Add a forcing term to rhs.
! Random, isotropic, homogenious in first 2 wave nubmers
!
! if new_f=0, add previously computed forcing stored in rmodes() into RHS. 
! if new_f=1, compute a new forcing ONLY, store in rmodes()
!
! numb1,numb2:   force bands [numb1,numb2]
!
use params
use mpi
implicit none
integer :: new_f
real*8 :: Qhat(g_nz2,nx_2dz,ny_2dz,3) 
real*8 :: rhs(g_nz2,nx_2dz,ny_2dz,3) 
integer km,jm,im,i,j,k,n,wn,ierr
real*8 xw,xfac,f_diss,fsum,fxx_diss

real*8,save :: rmodes(-numbs:numbs,-numbs:numbs,-numbs:numbs,3)       ! value at time tmod
real*8,save :: tmod,tmod_old
real*8,save :: tscale=.01


if (0==init_sforcing) then
   if (forcing_type==2) then
      numb1=1
      numb=2
      FM(1) = 18/(2*pi)**2    ! 15,15,0 yields: mu <ux,ux> = .5
      FM(2) = 18/(2*pi)**2
      FM(3) = 0
   endif
   if (forcing_type==4) then
      numb1=2
      numb=3
      FM(1) = 0    ! choose these so that mu <ux,ux> = .5
      FM(2) = 30    ! 0,5,5: epsilon: .09     R_l=35  E=.08
      FM(3) = 30    ! 0,15,15:        .27     R_l=45  E=.19
                    ! 0,30,30:        .56     R_l=49  E=.30
   endif

   call sforcing_init()
   rmodes=0
   tmod=0

   ! check that we are not including any wave numbers > numbs
   do wn=numb1,numb
   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)
      if (abs(z_imcord(i))>numbs .or. abs(z_jmcord(j))>numbs .or. abs(z_kmcord(k))>numbs)  then 
           call abortdns("Index error in sforcing_random12")
      endif
   enddo
   enddo
endif

if (ntot==0) return
!
! only CPUS which belong to "comm_sforcing" beyond this point!
!

!
! rmodes is at time  tmod
!

!
! Compute a new forcing function?  
!
if (new_f==1) then
   if (my_pe==io_pe) call random12(rmodes)
#ifdef USE_MPI
   call mpi_bcast(rmodes,3*(2*numbs+1)**3,MPI_REAL8,io_pe,comm_sforcing ,ierr)
#endif
   return
endif



f_diss=0
fxx_diss=0
do wn=numb1,numb
   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)

      rhs(k,i,j,1)=rhs(k,i,j,1) + rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1)
      rhs(k,i,j,2)=rhs(k,i,j,2) + rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2)
      rhs(k,i,j,3)=rhs(k,i,j,3) + rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3)

      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2
      fsum= ( &
         Qhat(k,i,j,1)*rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1) +&
         Qhat(k,i,j,2)*rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2) +&
         Qhat(k,i,j,3)*rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3) )
      
      f_diss = f_diss + xfac*fsum
      xw=-(z_imcord(i)**2 + z_jmcord(j)**2 + z_kmcord(k)**2)*pi2_squared
      fxx_diss = fxx_diss + xfac*xw*fsum

   enddo

enddo



end subroutine 
   



subroutine stochastic_highwaveno(rhs,Qhat,f_diss,fxx_diss,new_f)
!
! Add a forcing term to rhs.
! Random, isotropic, homogenious in first 2 wave nubmers
!
! if new_f=0, add previously computed forcing stored in rmodes() into RHS. 
!
! if new_f=1, compute a new forcing ONLY, store in internal static variable
!             This will TRASH rhs - used as a work array
!
! numb1,numb2:   force bands [numb1,numb2]
!
use params
use mpi
implicit none
integer :: new_f
real*8 :: Qhat(g_nz2,nx_2dz,ny_2dz,n_var) 
real*8 :: rhs(g_nz2,nx_2dz,ny_2dz,n_var) 
integer km,jm,im,i,j,k,n,ierr,ntest,wn,wn2,ii
real*8 xfac,f_diss,fsum,fxx_diss,vor(3),ux,uy,uz,wx,wy,wz,vx,vy,vz,xw,wnx
real*8  :: f_diss_pe, f_diss_ke_global, f_diss_pe_global
real*8,save,allocatable :: fhat(:,:,:,:)


real*8 ener(512),ener2(512),ener_test(512),ffnorm,ener_pe(512),ener_test_pe(512)
integer,save :: numk(512),numk2(512)
real*8,save :: ener_target(512)
integer,save :: fwidth, nf_comp
integer :: count 
integer,save :: kzmod


if (0==init_sforcing) then
   init_sforcing=1

   if (ndim==3) then
      nf_comp = 3
      if (force_theta) nf_comp=4
   else
      nf_comp = 2
   endif

   ! only force waves in z with mod(kz,kzmod)==0)
   ! default = 1, NO EFFECT.
   kzmod = 1

   ! set the width of the forcing.  If fparam1==0, we use the 
   ! default (fwidth=8).  To get fwidth=0, specify in the input 
   ! file fparam1=.1  (non zero, but will round to zero below)
   if (fparam1==0) then
      ! default is +/- 8  
      fwidth=8
   elseif (fparam1>10000) then
      fwidth=fparam1-10000
      kzmod = 4
   else
      ! otherwise, it was specified in the input file:
      ! fparam1 < 0   means use older forcing function
      fwidth = abs(fparam1)
   endif
   if (io_pe==my_pe) then
      print *,'Stochastic high wavenumber forcing initialization:'
      write(*,'(a,i3,a,i2)') 'Forcing wave numbers: ',forcing_peak_waveno,'+/-',fwidth
      write(*,'(a,f8.4)') 'sqrt( <f,f> ) = ',ffval
   endif
   
   if (force_theta) then
      allocate(fhat(g_nz2,nx_2dz,ny_2dz,4))
   else
      allocate(fhat(g_nz2,nx_2dz,ny_2dz,3))
   endif
   numb1=max(forcing_peak_waveno-fwidth,1)
   numb=forcing_peak_waveno+fwidth
   ener_target=0
!   print *,'kzmod = ',kzmod
   do wn=numb1,numb
      ! note: my wave numbers have an extra 2pi.
      if (fparam1<0) then
         if(infinite_alpha==1) then
            ener_target(wn)=ffval*exp(-.5*(wn-forcing_peak_waveno)**2)/sqrt(2*pi)
         else
            ener_target(wn)=ffval*exp(-.5*(wn-forcing_peak_waveno)**2)/sqrt(2*pi)
         endif
         ! original forcing function. I'm not sure if <f,f>=ffval  
         !ener_target(wn)=ffval*exp(-.5*(wn-forcing_peak_waveno)**2)/sqrt(2*pi)    
      else
         ! Smith & Waleffe: F(k) = eps_f exp( -.5 (k-k0)**2 )  /  sqrt(2pi)
         ! this is the power spectrum of the forcing function f(k)
         ! .5 f(k)^2 = F(k)
         ! which gives:    <f,f> = 2 sum(F(k)) = 2 eps_f
         ! so that d/dt(KE) = <u,f> = .5 <f,f> = eps_f
         !
         ! However, below I defined the energy in the forcing term as f^2
         ! (not .5 f^2), so that f(k)^2 = F(k)
         ! This is normalized so that <f,f> = sum(F(k)) = ffval
         ! and thus eps_f = <u,f> = .5 <f,f> = .5 ffval
         !
         ener_target(wn)=ffval*exp((-2*pi*pi/(kzmod*kzmod))*(wn-forcing_peak_waveno)**2)
      endif
   enddo


   ! compute number of coefficients in each band
   numk=0
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)

            ! use "fat shells for Lz < 1 (shell_thickness_scale=Lz) and Lz > 1 (shell_thickness_scale=1);
            wn=shell_thickness_scale*sqrt(real(im*im+jm*jm+km*km/Lz/Lz))
            ! use "thin shells":
            ! wn=sqrt(real(im*im+jm*jm+km*km/Lz/Lz))
            if (wn<=numb .and. wn>=numb1 .and. mod(abs(km),kzmod)==0) then 
               numk(wn)=numk(wn)+1
!               print *,'Forcing wavenumbers in skewed forcing:',im, jm, km 
            endif
         enddo
      enddo
   enddo
#ifdef USE_MPI
   numk2=numk
   call mpi_allreduce(numk2,numk,numb,MPI_INTEGER,MPI_SUM,comm_3d,ierr)
#endif      
   
   
   ! print all wave numbers being forced:
   if (io_pe .eq. my_pe) then
      print *,'Stochastic forcing'
      if (force_theta) then
         print *,'Forcing u,v,w and theta'
      else
         print *,'Forcing u,v,w only'
      endif
      print *,'wave#    # modes forced'
      do i=1,512
         if (numk(i)>0) then
            write(*,'(i4,i15)') i,numk(i)
         endif
      enddo
   endif
endif



! ntest=10; delt=1.0  ! set > 1 to run some stats tests
ntest=1
if (new_f==1) then
   ener2=0
   ener_test=0
   ener_test_pe=0
   do ii=1,ntest

   ! compute forcing function fhat:
   ener=0
   call gaussian(rhs,g_nz2*nx_2dz*ny_2dz*3)
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)
            wn2=(im*im+jm*jm+km*km/Lz/Lz)
            wn = shell_thickness_scale*sqrt(real(wn2))
            wnx = sqrt(real(wn2))
            ! we uses FAT SHELLS for the test, but the true wave number wnx
            ! for normalizations below
            if (numb1 <= wn .and. wn <= numb .and. delt>0 .and. mod(abs(km),kzmod)==0) then
               
               xfac=8
               if (km==0) xfac=xfac/2
               if (jm==0) xfac=xfac/2
               if (im==0) xfac=xfac/2

               ! f=curl f
               ! compute gradient  dp/dx
               uy= - jm*rhs(k,i,j+z_jmsign(j),1)
               ux= - im*rhs(k,i+z_imsign(i),j,1)
               uz= - km*rhs(k+z_kmsign(k),i,j,1)/Lz
               vx= - im*rhs(k,i+z_imsign(i),j,2)
               vz= - km*rhs(k+z_kmsign(k),i,j,2)/Lz
               wx= - im*rhs(k,i+z_imsign(i),j,3)
               wy= - jm*rhs(k,i,j+z_jmsign(j),3)

               if (ndim==3) then
                  vor(1) = wy - vz
                  vor(2) = uz - wx 
                  vor(3) = vx - uy
                  ! scale out various shell factors:
                  vor=vor/sqrt(xfac*numk(wn)*nf_comp)
                  ! undo curl scaling:  (2/3) wn**2
                  vor = vor * sqrt(1.5)/ wnx
                  ! vorticity now scaled so that E(wn)=1
               else
                  vor(1) = uy
                  vor(2) = -ux
                  vor(3) = 0
                  ! scale out various shell factors:
                  vor=vor/sqrt(xfac*numk(wn)*nf_comp)
                  ! undo gradient scaling: should be .5 wn**2
                  vor = vor * sqrt(2.) /  wnx
                  ! vorticity now scaled so that E(wn)=1
               endif


               do n=1,3
                  vor(n)=vor(n)*sqrt(ener_target(wn)/delt)
                  fhat(k,i,j,n)=vor(n)
                  ener(wn)=ener(wn)+xfac*fhat(k,i,j,n)**2
               enddo
            else
               do n=1,3
                  fhat(k,i,j,n)=0
               enddo
            endif
         enddo
      enddo
   enddo

   ! compute forcing function fhat for scalar:
   ener_pe=0
   if (force_theta .and. npassive>0) then
!   ener_pe=0   
   call gaussian(rhs,g_nz2*nx_2dz*ny_2dz)
   n=np1
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)
            wn2=(im*im+jm*jm+km*km/Lz/Lz)
            wn = shell_thickness_scale*sqrt(real(wn2))
            wnx = sqrt(real(wn2))
            ! we uses FAT SHELLS for the test, but the true wave number wnx
            ! for normalizations below
            if (numb1 <= wn .and. wn <= numb .and. delt>0 .and. mod(abs(km),kzmod)==0) then
               
               xfac=8
               if (km==0) xfac=xfac/2
               if (jm==0) xfac=xfac/2
               if (im==0) xfac=xfac/2

               ux = rhs(k,i,j,1)
               ux=ux/sqrt(xfac*numk(wn)* nf_comp )
               fhat(k,i,j,n)=ux*sqrt(ener_target(wn)/delt)
               ener_pe(wn)=ener_pe(wn)+xfac*fhat(k,i,j,n)**2
            else
               fhat(k,i,j,n)=0
            endif
         enddo
      enddo
   enddo
   endif

   if (ntest>1) then
      if (io_pe==my_pe) print *,"iter=",ii,numb1,numb,sum(ener(numb1:numb))
#ifdef USE_MPI
      ener2=ener
      call mpi_allreduce(ener2,ener,numb,MPI_REAL8,MPI_SUM,comm_3d,ierr)
      ener2=ener_pe            
      call mpi_allreduce(ener2,ener_pe,numb,MPI_REAL8,MPI_SUM,comm_3d,ierr)
#endif      
      ener_test=ener_test+ener/ntest
      ener_test_pe=ener_test_pe+ener_pe/ntest
   endif
   enddo

   if (ntest>1) then
   if (io_pe==my_pe) then
      print *,'forcing_ke:  ',sum(ener_test(numb1:numb))
      print *,'forcing_pe:  ',sum(ener_test_pe(numb1:numb))
      print *,'k,#modes,ener_target,ener_ke,ener_pe'
      do n=numb1,numb
         print *,n,numk(n),ener_target(n),ener_test(n),ener_test_pe(n)
      enddo
   endif
   stop
   endif

   return
endif


! apply forcing function:
f_diss=0
fxx_diss=0

do n=1,ndim
do j=1,ny_2dz
   jm=z_jmcord(j)
   do i=1,nx_2dz
      im=z_imcord(i)
      do k=1,g_nz
         km=z_kmcord(k)

         rhs(k,i,j,n)=rhs(k,i,j,n) + fhat(k,i,j,n)
         
         xfac=8
         if (km==0) xfac=xfac/2
         if (jm==0) xfac=xfac/2
         if (im==0) xfac=xfac/2
         fsum= Qhat(k,i,j,n)*fhat(k,i,j,n)
         
         f_diss = f_diss + xfac*fsum
         xw=-(im*im + jm*jm + km*km/Lz/Lz)*pi2_squared
         fxx_diss = fxx_diss + xfac*xw*fsum
      enddo
   enddo
enddo
enddo

f_diss_pe=0
if (force_theta .and. npassive>0) then
   n=np1
   do j=1,ny_2dz
      jm=z_jmcord(j)
      do i=1,nx_2dz
         im=z_imcord(i)
         do k=1,g_nz
            km=z_kmcord(k)
            
            rhs(k,i,j,n)=rhs(k,i,j,n) + fhat(k,i,j,n)
            
            xfac=8
            if (km==0) xfac=xfac/2
            if (jm==0) xfac=xfac/2
            if (im==0) xfac=xfac/2
            fsum= Qhat(k,i,j,n)*fhat(k,i,j,n)
            
            f_diss_pe = f_diss_pe + xfac*fsum
            xw=-(im*im + jm*jm + km*km/Lz/Lz)*pi2_squared
            fxx_diss = fxx_diss + xfac*xw*fsum
         enddo
      enddo
   enddo
endif


#if 0 
   call mpi_allreduce(f_diss,xfac,1,MPI_REAL8,MPI_SUM,comm_3d,ierr)
   if (io_pe==my_pe) then
      print *,'f_diss: ',xfac,maxval(fhat)
   endif
#endif

#if 0 
   call mpi_allreduce(f_diss,f_diss_ke_global,1,MPI_REAL8,MPI_SUM,comm_3d,ierr)
   call mpi_allreduce(f_diss_pe,f_diss_pe_global,1,MPI_REAL8,MPI_SUM,comm_3d,ierr)
   if (io_pe==my_pe) then
      print *,'eps_f  ke,pe:  ',f_diss_ke_global,f_diss_pe_global
   endif
#endif

f_diss = f_diss + f_diss_pe

end subroutine 
   
   

subroutine random12(rmodes)
use params
implicit none
real*8 :: rmodes(-numbs:numbs,-numbs:numbs,-numbs:numbs,3)       

integer km,jm,im,i,j,k,n,wn,ierr,k2,count,countmax
real*8 xw,xfac,f_diss
real*8 :: R(-numbs:numbs,-numbs:numbs,-numbs:numbs,3,2),Rr,Ri
real*8 :: psix_r(3),psix_i(3)
real*8 :: psiy_r(3),psiy_i(3)
real*8 :: psiz_r(3),psiz_i(3)
real*8 :: ff(numbs,3)

integer :: zerosign
external :: zerosign

#undef GATHER_STATS
#ifdef GATHER_STATS
ff=0
Ri=3
countmax=1000000
do count=1,countmax

call gaussian(rmodes,((2*numbs+1)**3) *3)
do wn=numb1,numb

   do n=1,wnforcing(wn)%n
      i=wnforcing(wn)%index(n,1)
      j=wnforcing(wn)%index(n,2)
      k=wnforcing(wn)%index(n,3)

      xfac=8
      if (z_kmcord(k)==0) xfac=xfac/2
      if (z_jmcord(j)==0) xfac=xfac/2
      if (z_imcord(i)==0) xfac=xfac/2


      ff(wn,1)= ff(wn,1) + xfac*( &
         rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),1)**Ri )
      ff(wn,2)= ff(wn,2) + xfac*( &
         rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),2)**Ri )
      ff(wn,3)= ff(wn,3) + xfac*( &
         rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k),3)**Ri )


   enddo

enddo
enddo
ff=abs(ff/countmax)**(1/Ri)
print *,'count=',countmax
print *,'<R,R> ='
do wn=numb1,numb
   print *,ff(wn,:)
enddo
call abortdns("end stats")
#endif




rmodes=0
call gaussian(R,((2*numbs+1)**3) *3*2)





do km=-numb,numb 
do jm=-numb,numb
do im=-numb,numb
   !
   ! Choose R gaussian, theta uniform from [0..1]
   ! vorticty = (R1 + i R2)  exp(im*2pi*x) * exp(jm*2pi*y) * exp(km*2pi*z) 
   !
   ! R = vorticity
   ! PSI = laplacian^-1 R
   ! f = curl R 
   !
   ! code above (#define COMPUTE_STATS) shows that
   !  k=1  <R,R> = 180
   !  k=2  <R,R> = 1090
   !  k=3  <R,R> = 1809
   !
   k2 = (im**2 + jm**2 + km**2)
   ! ignore wave numbers outside of our forcing band 
   if ((numb1-.5)**2 <=k2 .and.   k2 < (numb+.5)**2) then

      if (k2>0) then
         xfac=1/(-2*pi*k2)
      else
         xfac=0
      endif
      if (delt>0) xfac=xfac/sqrt(delt)
      ! normalize so that < R**2 >   = F1  in wave number 1
      ! normalize so that < R**2 >   = F2  in wave number 2
      if (k2 < 1.5**2) then
         xfac=xfac*sqrt(FM(1)/180)
      else if (k2 < 2.5**2)  then
         xfac=xfac*sqrt(FM(2)/1090)
      else if (k2 < 3.5**2)  then
         xfac=xfac*sqrt(FM(3)/1809)
      endif
      


      do n=1,3
         psix_r(n) = -im*R(im,jm,km,n,2)*xfac
         psix_i(n) =  im*R(im,jm,km,n,1)*xfac
         psiy_r(n) = -jm*R(im,jm,km,n,2)*xfac
         psiy_i(n) =  jm*R(im,jm,km,n,1)*xfac
         psiz_r(n) = -km*R(im,jm,km,n,2)*xfac
         psiz_i(n) =  km*R(im,jm,km,n,1)*xfac
      enddo


      ! vor(1) = w_y - v_z
      ! vor(2) = u_z - w_x 
      ! vor(3) = v_x - u_y
      do n=1,3
         if (n==1) then
            Rr = psiy_r(3) - psiz_r(2)
            Ri = psiy_i(3) - psiz_i(2)
         else if (n==2) then
            Rr = psiz_r(1) - psix_r(3)
            Ri = psiz_i(1) - psix_i(3)
         else if (n==3) then
            Rr = psix_r(2) - psiy_r(1)
            Ri = psix_i(2) - psiy_i(1)
         endif

         
         i=abs(im)
         j=abs(jm)
         k=abs(km)
         ! code taken from complex_to_sincos().  Any bug fixes here,
         ! be sure to apply to that function also.
         rmodes( i, j, k,n) = rmodes( i, j, k,n) + Rr 
         rmodes( i, j,-k,n) = rmodes( i, j,-k,n) - Ri*zerosign(km) 
         rmodes( i,-j, k,n) = rmodes( i,-j, k,n) - Ri*zerosign(jm) 
         rmodes( i,-j,-k,n) = rmodes( i,-j,-k,n) - Rr*zerosign(jm*km) 
         rmodes(-i, j, k,n) = rmodes(-i, j, k,n) - Ri*zerosign(im)
         rmodes(-i, j,-k,n) = rmodes(-i, j,-k,n) - Rr*zerosign(im*km) 
         rmodes(-i,-j, k,n) = rmodes(-i,-j, k,n) - Rr*zerosign(im*jm) 
         rmodes(-i,-j,-k,n) = rmodes(-i,-j,-k,n) + Ri*zerosign(im*jm*km) 
      enddo
   endif
enddo
enddo
enddo
end subroutine










subroutine zdecomp_to_rmodes(p,rmodes,nmax)
!
! extract sine and cosine modes from p, store in rmodes
!
use params
use mpi
implicit none
integer :: nmax
real*8 :: rmodes(-nmax:nmax,-nmax:nmax,-nmax:nmax)
real*8 :: rmodes2(-nmax:nmax,-nmax:nmax,-nmax:nmax)
real*8 :: p(g_nz2,nx_2dz,ny_2dz)
integer :: i,j,k,ierr

rmodes=0
do j=1,ny_2dz
do i=1,nx_2dz
do k=1,g_nz
   if (abs(z_imcord(i))<=nmax .and. abs(z_jmcord(j))<=nmax .and. &
       abs(z_kmcord(k))<=nmax ) then
      rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k)) = p(k,i,j) 
   endif
enddo
enddo
enddo
#ifdef USE_MPI
i=2*nmax+1
i=i*i*i
rmodes2=rmodes
call mpi_allreduce(rmodes2,rmodes,i,MPI_REAL8,MPI_SUM,comm_3d,ierr)

#endif

end subroutine




subroutine rmodes_to_zdecomp(p,rmodes,nmax)
!
! extract sine and cosine modes from rmodes, store in p
!
use params
implicit none
integer :: nmax
real*8 :: rmodes(-nmax:nmax,-nmax:nmax,-nmax:nmax)
real*8 :: p(g_nz2,nx_2dz,ny_2dz)
integer :: i,j,k

do j=1,ny_2dz
do i=1,nx_2dz
do k=1,g_nz
   if (abs(z_imcord(i))<=nmax .and. abs(z_jmcord(j))<=nmax .and. &
       abs(z_kmcord(k))<=nmax ) then
       p(k,i,j) = rmodes(z_imcord(i),z_jmcord(j),z_kmcord(k)) 
   endif
enddo
enddo
enddo



end subroutine






subroutine complex_to_sincos(rmodes,cmodes,nmax)
!
!  convert set of complex FFT coefficients to sine and cosines
!
use params
implicit none
integer :: nmax
real*8 :: Rr,Ri
real*8 :: cmodes(2,-nmax:nmax,-nmax:nmax,-nmax:nmax)
real*8 :: rmodes(-nmax:nmax,-nmax:nmax,-nmax:nmax)
integer :: i,j,k,im,jm,km,imax,ip,jp,kp
integer :: zerosign
external :: zerosign
!
! Note: this code also used in random12() above. 
! Any bugfixes here, also apply to random12().
!   
! convert to sine & cosine modes:
!
! (R1 + i R2) (cosx + i sinx)  (cosy + i siny)  (cosz + i sinz)  
! = (real parts only:)
!   R1  cosx cosy cosz                      R1 (1,1,1)
! i R2  cosx cosy sinz  i                  -R2 (1,1,-1) zerosign(km) 
! i R2  cosx siny cosz  i                  -R2 (1,-1,1) zerosign(jm)
!   R1  cosx siny sinz  i**2               -R1 (1,-1,-1) zerosign(km*jm)
! i R2  sinx cosy cosz  i                  -R2 (-1,1,1) zerosign(im) 
!   R1  sinx cosy sinz  i**2               -R1 (-1,1,-1) zerosign(im*km)
!   R1  sinx siny cosz  i**2               -R1 (-1,-1,1) zerosign(im*jm)
! i R2  sinx siny sinz  i**3                R2 (-1,-1,-1) zerosign(im*jm*km)
!  
! 

rmodes=0

do im=-nmax,nmax
do jm=-nmax,nmax
do km=-nmax,nmax
   Rr = cmodes(1,im,jm,km)
   Ri = cmodes(2,im,jm,km)

   i=abs(im)
   j=abs(jm)
   k=abs(km)
   
   rmodes( i, j, k) = rmodes( i, j, k) + Rr 
   rmodes( i, j,-k) = rmodes( i, j,-k) - Ri*zerosign(km) 
   rmodes( i,-j, k) = rmodes( i,-j, k) - Ri*zerosign(jm) 
   rmodes( i,-j,-k) = rmodes( i,-j,-k) - Rr*zerosign(jm*km) 
   rmodes(-i, j, k) = rmodes(-i, j, k) - Ri*zerosign(im)
   rmodes(-i, j,-k) = rmodes(-i, j,-k) - Rr*zerosign(im*km) 
   rmodes(-i,-j, k) = rmodes(-i,-j, k) - Rr*zerosign(im*jm) 
   rmodes(-i,-j,-k) = rmodes(-i,-j,-k) + Ri*zerosign(im*jm*km) 

enddo
enddo
enddo



end subroutine








subroutine sincos_to_complex(rmodes,cmodes,nmax)
!
!  convert set of sine and cosine FFT coefficients to complex coefficients
!
#if 0
   conversion to complex coefficients:
        a cos(lx) cos(my) cos(nz)
      
        sign(>=0)=1
        sign(<0)=-1

        p = number of negative values in sign(l), sign(m), sign(n):   
        1/i**0    1
        1/i**1   -i
        1/i**2   -1
        1/i**3    i


        a/(8 i**p) (exp(ilx)+sign(l)exp(-ilx))
                   (exp(imy)+sign(m)exp(-imy))
                   (exp(inz)+sign(n)exp(-inz))

        ( l, m, n)
        ( l, m,-n) sign(n)
        ( l,-m, n) sign(m)
        ( l,-m,-n) sign(n)*sign(m)
        (-l, m, n) sign(l)
        (-l, m,-n) sign(l)*sign(n)
        (-l,-m, n) sign(l)*sign(m)
        (-l,-m,-n) sign(l)*sign(m)*sign(n)

#endif      
use params
implicit none
integer :: nmax
real*8 :: rmodes(-nmax:nmax,-nmax:nmax,-nmax:nmax)
real*8 :: cmodes(2,-nmax:nmax,-nmax:nmax,-nmax:nmax)
real*8 :: a,b
integer :: i,j,k,im,jm,km,imax,sm,ip,jp,kp

imax=2*nmax+2
cmodes=0

do im=-nmax,nmax
do jm=-nmax,nmax
do km=-nmax,nmax

   ip=abs(im)
   jp=abs(jm)
   kp=abs(km)


   a=0; b=0

   ! count the number if sin() terms:
   sm=0; if (im<0) sm=sm+1;  if (jm<0) sm=sm+1;  if (km<0) sm=sm+1

   if (sm==0) then
      a=rmodes(im,jm,km)/8
   else if (sm==1) then
      b=-rmodes(im,jm,km)/8
   else if (sm==2) then
      a=-rmodes(im,jm,km)/8
   else if (sm==3) then
      b=rmodes(im,jm,km)/8
   else
      call abortdns("this cant happen")
   endif

   cmodes(1,ip,jp,kp)=cmodes(1,ip,jp,kp) + a;    
   cmodes(2,ip,jp,kp)=cmodes(2,ip,jp,kp) + b

   cmodes(1,ip,jp,-kp)=cmodes(1,ip,jp,-kp) + a*sign(1,km)   
   cmodes(2,ip,jp,-kp)=cmodes(2,ip,jp,-kp) + b*sign(1,km)

   cmodes(1,ip,-jp,kp)=cmodes(1,ip,-jp,kp) + a*sign(1,jm)
   cmodes(2,ip,-jp,kp)=cmodes(2,ip,-jp,kp) + b*sign(1,jm)

   cmodes(1,ip,-jp,-kp)=cmodes(1,ip,-jp,-kp) + a*sign(1,jm)*sign(1,km)  
   cmodes(2,ip,-jp,-kp)=cmodes(2,ip,-jp,-kp) + b*sign(1,jm)*sign(1,km)  

   cmodes(1,-ip,jp,kp)=cmodes(1,-ip,jp,kp) + a*sign(1,im)
   cmodes(2,-ip,jp,kp)=cmodes(2,-ip,jp,kp) + b*sign(1,im)

   cmodes(1,-ip,jp,-kp)=cmodes(1,-ip,jp,-kp) + a*sign(1,im)*sign(1,km)
   cmodes(2,-ip,jp,-kp)=cmodes(2,-ip,jp,-kp) + b*sign(1,im)*sign(1,km)

   cmodes(1,-ip,-jp,kp)=cmodes(1,-ip,-jp,kp) + a*sign(1,im)*sign(1,jm)
   cmodes(2,-ip,-jp,kp)=cmodes(2,-ip,-jp,kp) + b*sign(1,im)*sign(1,jm)

   cmodes(1,-ip,-jp,-kp)=cmodes(1,-ip,-jp,-kp) + a*sign(1,im)*sign(1,jm)*sign(1,km)
   cmodes(2,-ip,-jp,-kp)=cmodes(2,-ip,-jp,-kp) + b*sign(1,im)*sign(1,jm)*sign(1,km)

enddo
enddo
enddo
end subroutine





end module
